//
// A simple sequential MapReduce for WordCount
//

#include <string>
#include <sstream>
#include <fstream>
#include <iostream>
#include <vector>
#include <unordered_map>
#include <algorithm>
#include <cctype>

using namespace std;

#define DEBUG

#ifdef DEBUG
  #define LOG(format, args...) do {   \
    FILE* debug_log = fopen("sequential.log", "a+");  \
    fprintf(debug_log, "%d, %s: ", __LINE__, __func__); \
    fprintf(debug_log, format, ##args); \
    fclose(debug_log);\
  } while (0)
#endif

typedef struct {
    string key;
    string val;
}
KeyVal;

//
// The map function is called once for each file of input. The first
// argument is the name of the input file, and the second is the
// file's complete contents. You should ignore the input file name,
// and look only at the contents argument. The return value is a slice
// of key/value pairs.
//
vector<KeyVal> Map(const string &filename, const string &content)
{
    // Your code goes here
    // Hints: split contents into an array of words.
    vector<KeyVal> result;
    unordered_map<std::string, uint64_t> word_map;

    std::size_t begin_pos = 0;
    bool in_word = false;
    std::string word;

    // suppose the file is not too long
    std::size_t file_size = content.size();

    // different from paper, also do some reduce work
    for (std::size_t i = 0; i < file_size; ++i) {
        if (isalpha(content[i])) {
            if (!in_word) {
                in_word = true;
                begin_pos = i;
            }
        } else {
            if (in_word) {
                in_word = false;
                word = content.substr(begin_pos, i - begin_pos);
                begin_pos = i + 1;

                if(!word.empty()) {
                    if (word_map.count(word)) {
                        word_map[word] += 1;
                    } else {
                        word_map[word] = 1;
                    }
                }
            }
        }
    } 

    // handle the tail word
    if (begin_pos != file_size && in_word) {
        word = content.substr(begin_pos);

        if (!word.empty() && isalpha(word[0])) {
            if (word_map.count(word)) {
                word_map[word] += 1;
            } else {
                word_map[word] = 1;
            }
        }
    }

    // generate the result
    for (auto elem : word_map) {
        KeyVal new_key_val;
        new_key_val.key = elem.first;
        new_key_val.val = to_string(elem.second);

        // std::cout << "key: " << new_key_val.key <<  " val: " << new_key_val.val << std::endl;
        result.emplace_back(new_key_val);
    }

    return result;
}

//
// The reduce function is called once for each key generated by the
// map tasks, with a list of all the values created for that key by
// any map task.
//
string Reduce(const string &key, const vector <string> &values)
{
    // Your code goes here
    // Hints: return the number of occurrences of the word.
    uint64_t count = 0;
    for (auto val : values) {
        count += std::stoul(val);
    }

    return to_string(count);
}

int main(int argc, char ** argv)
{
    if (argc < 2) {
        cout << "Usage: mrsequential inputfiles...\n";
        exit(1);
    }

    vector <string> filename;
    vector <KeyVal> intermediate;

    //
    // read each input file,
    // pass it to Map,
    // accumulate the intermediate Map output.
    //

    for (int i = 1; i < argc; ++i) {

        string filename = argv[i];
        string content;

        // Read the whole file into the buffer.
        getline(ifstream(filename), content, '\0');

        vector <KeyVal> KVA = Map(filename, content);

        intermediate.insert(intermediate.end(), KVA.begin(), KVA.end());

    }

    //
    // a big difference from real MapReduce is that all the
    // intermediate data is in one place, intermediate[],
    // rather than being partitioned into NxM buckets.
    //

    sort(intermediate.begin(), intermediate.end(),
    	[](KeyVal const & a, KeyVal const & b) {
		return a.key < b.key;
	});

    //
    // call Reduce on each distinct key in intermediate[],
    // and print the result to mr-out-0.
    //

    for (unsigned int i = 0; i < intermediate.size();) {
        unsigned int j = i + 1;
        for (; j < intermediate.size() && intermediate[j].key == intermediate[i].key;)
            j++;

        vector < string > values;
        for (unsigned int k = i; k < j; k++) {
            values.push_back(intermediate[k].val);
        }

        string output = Reduce(intermediate[i].key, values);
        printf("%s %s\n", intermediate[i].key.data(), output.data());

        i = j;
    }
    return 0;
}

